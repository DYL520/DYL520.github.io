<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>虫子小孩</title>
  
  <subtitle>有生之年，只诉衷肠不言殇....</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://dyl521.github.io/"/>
  <updated>2018-07-09T08:49:00.175Z</updated>
  <id>https://dyl521.github.io/</id>
  
  <author>
    <name>DYL</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>django项目部署</title>
    <link href="https://dyl521.github.io/2016/10/11/django%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    <id>https://dyl521.github.io/2016/10/11/django项目部署/</id>
    <published>2016-10-11T08:13:00.000Z</published>
    <updated>2018-07-09T08:49:00.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1、项目代码打包部署"><a href="#1、项目代码打包部署" class="headerlink" title="1、项目代码打包部署"></a>1、项目代码打包部署</h2><p> 包压缩技巧：</p><p> tar    -cjvf    python3.6env.tar.bz2     python3.6env/<br> tar   xjvf   python3.6_env.tar.bz2 </p><p>一、压缩拷贝代码：</p><p>（1）进入工程主目录<br>    cd  项目名称<br>（2）产生依赖库  pip freeze &gt; requirements.txt<br>（3）压缩<br>    cd  项目名称<br> zip -r 项目名称.zip 项目名称/</p><h2 id="二、远程拷贝"><a href="#二、远程拷贝" class="headerlink" title="二、远程拷贝"></a>二、远程拷贝</h2><p>服务器端(ubuntu)：</p><p>nc   -l   11111  &gt; 项目名称.zip</p><p>客户端：</p><p>nc   IP   11111   &lt;   项目名称.zip</p><h2 id="三、配置环境，-解压"><a href="#三、配置环境，-解压" class="headerlink" title="三、配置环境， 解压"></a>三、配置环境， 解压</h2><p>  python依赖的环境：  python3.5 或者 python3.6</p><p>  安装并配置虚拟环境：</p><p>  source   python3.6/bin/activate</p><p>  进入虚拟环境</p><p>  pip   install  -r    requirements.txt  -i <a href="http://pypi.douban.com/simple（修改源为豆瓣源）" target="_blank" rel="noopener">http://pypi.douban.com/simple（修改源为豆瓣源）</a></p><p>  查看环境依赖：pip  list</p><h2 id="四、启动服务"><a href="#四、启动服务" class="headerlink" title="四、启动服务"></a>四、启动服务</h2><p>确认redis， mysql安装良好，能访问</p><p>setings.py 中  ALLOWS = [‘*’]</p><p>启动服务</p><p>python  manage.py  runserver   0.0.0.0:8000 </p><p>(无问题情况，在后台运行：<br> nohup  python  manage.py  runserver   0.0.0.0:8000  &amp;<br>)<br>2  项目分布式部署的整体框架图</p><p>why要用openresty？</p><pre><code>直接使用Nginx，开发成为一个很大的难题    ，需要使用C语言开发，并且要符合一系列的规则，而且要熟悉NGINX的源代码，所以openrestyl可以使用lua语言规范开发，实现各种业务逻辑，大大降低开发的难度（Lua语言是由C语言编写的，小巧的脚本语言，嵌入性很好）WSGI：一种实现python解析通用的接口标准协议(WEB 服务器网关接口 )，不是服务器、python模块、框架、API或者任何软件-- 只是一种描述WEB服务器（如nginx，uWSGI等服务器如何与web应用程序（如Django、Flask框架写的程序）通信规范uwsgi:是一种线路协议不是通信协议，uWSGI服务器与其他网络服务器的通信uWSGI:    是uwsgi和WSGI两种协议的web服务器，把Http协议转成语言支持的网络协议，比如，在Django中，把HTTP协议，转化成WSGI协议，让django直接使用，Django只需要解析request和返回responseNginx：是一个WEB服务器，其中的HTTP服务器功能和uWSGI类似，但是nginx有更多的功能：比如，反向代理，负载均衡，静态资源管理，epoll网络模型（IO多路复用）等django：在网络方面主要处理的是request和返回response，其他部署是他不关心的</code></pre><p>参考：<a href="https://blog.csdn.net/yjk13703623757/article/details/79457913" target="_blank" rel="noopener">https://blog.csdn.net/yjk13703623757/article/details/79457913</a></p><pre><code>一个成熟的网站，需要web服务器（静态数据）和APP服务器（动态数据）！</code></pre><p>性能优化：    </p><pre><code>nginx：主要优化连接数，和静态文件 uWSGI：优化wsgi服务</code></pre><p>其他优化手段：</p><pre><code>优化数据库：增加缓存负载均衡引入异步IO框架（gunicorn ）计算密集型模块用C重写等等</code></pre><p>提供两种方案，一个备选方案：</p><p>方案1：</p><p>Nginx(openresty)    —&gt;   gunicorn (同uwsgi)     —&gt;  django （应用服务）</p><p>方案2：</p><p>Nginx(openresty, upstream)    —&gt; supervisor (monitor ) ——&gt;  gunicorn (同uwsgi)     —&gt;  django </p><p>Nginx：负载均衡、反向代理、静态资源管理，日志等（直接返回，不进入app）</p><p>supervisor：若是gunicorn挂了，自动拉起gunicorn</p><p>gunicorn ：管理多个进程，gunicorn配置的进程（配置的是真实的app server）挂了，可以自动拉起！</p><p>supervisor：管理gunicorn ，会自动拉起gunicorn</p><p>Nginx：一般情况下不会挂</p><p>备选：</p><p>nohup python man</p><p>Nginx(openresty, upstream)  —&gt; supervisor(minitor) HTTP —&gt; django (HTTP)</p><p>使用如下框架和工具</p><ol><li>反向代理负载均衡服务器：  Nginx （Openresty）</li><li>gunicorn （代替uwsgi，gunicorn是一个uWSGI服务器）：托管django</li><li>django </li><li>supervisor （监控并拉起失败服务）</li></ol><p>1  安装项目依赖包</p><p>pip   list</p><p>采用pip freeze产生项目依赖包，输出到 requirements.txt</p><p>pip freeze &gt; requirements.txt</p><p>pip install -r requirements.txt  -i <a href="https://pypi:douban.com/simple" target="_blank" rel="noopener">https://pypi:douban.com/simple</a></p><p>拷贝requirements.txt文件到线上服务器，并在虚拟环境下安装</p><p>将线下项目工程目录打包，并用nc上传到服务器上。</p><p>假设线上的工程目录放在了 </p><p>2  安装gunicorn</p><pre><code>gunicorn是一个python Wsgi http server，只支持在Unix系统上运行，来源于Ruby的unicorn项目。Gunicorn使用prefork master-worker模型（在gunicorn中，master被称为arbiter），能够与各种wsgi web框架协作。</code></pre><p>在虚拟环境下安装上述的requirements.txt中对应的依赖包</p><p>（1）pip  install -r requirements.txt</p><p>注：</p><pre><code>pip install future -i https://pypi.douban.com/simple     (可能会安装)确保DjangoUeditor3安装成功，之前讲过从git下载安装</code></pre><p>（2）pip install gunicorn -i <a href="https://pypi.douban.com/simple" target="_blank" rel="noopener">https://pypi.douban.com/simple</a></p><p>（3）启动gunicorn， 命令如下：</p><p>具体chdir是项目的basedir目录</p><pre><code>nohup gunicorn --chdir /home/zhouguangyou/artproject/ artproject.wsgi:application  --bind 0.0.0.0:9000  --workers=2 &amp;   ## 后端启动### 我的是在home/dylnohup gunicorn --chdir /home/dyl/SHDjangoLesson/ SHDjangoLesson.wsgi:application  --bind 0.0.0.0:9000  --workers=2 &amp;   ## 后端启动</code></pre><p>3 关于静态资源管理</p><p>将分散在各个app应用中的静态资源集中管理，采用如下命令：</p><p>python manage.py collectstatic</p><p>此时会在base_dir目录下产生statics文件夹</p><p>后面nginx静态文件配置就可以指定此路径, 让Nginx找到这个静态文件的目录</p><p>4  配置Nginx服务器</p><p>在nginx服务器配置中修改配置目录</p><p>将nginx.conf修改为：</p><pre><code># user  nobody;# user nginx;worker_processes  2;        #cat /proc/cpuinfo# worker_cpu_affinity       0001 0010 0100 1000;error_log  logs/error.log  notice;# error_log  logs/error.log  debug;pid  logs/nginx.pid;events{    use   epoll;    multi_accept  on;    accept_mutex_delay  50ms;    worker_connections  65535;    #每个worker支持最大网络连接数，线上是65535个最大连接数--- }    http{    include  mime.types;    # default_type  application/octet-stream;     default_type   text/html;# log_format  main  &apos;$remote_addr - $remote_user [$time_local] &quot;$request&quot; &apos;#                  &apos;$status $body_bytes_sent &quot;$http_referer&quot; &apos;#                  &apos;&quot;$http_user_agent&quot; &quot;$http_x_forwarded_for&quot;&apos;#                  &apos;&quot;$upstream_addr&quot; &quot;$upstream_status&quot; &quot;$upstream_response_time&quot; &apos;#                  &apos;$request_time -- $http_cookie -- $cookie_pin&apos;;# access_log  logs/access.log  main;sendfile  on;tcp_nopush  on;keepalive_timeout  0;gzip  on;#gzip_min_length  1k; ####学习的时候注释掉#gzip_buffers 48k;   ## ##学习的时候注释掉#gzip_http_version  1.1; ##学习的时候注释掉gzip_types  text/plain application/x-javascript text/css  text/shtml application/xml;proxy_intercept_errors  on;charset  utf-8;######################include  conf.d/*.conf;######################}</code></pre><p>创建目录conf.d, 并添加如下信息到project.conf：</p><pre><code>proxy_next_upstream  error;server{    listen 8000;       #nginx提供对外的端口是8000， 通过路由 / 转发到127.0.0.1:9000/art/index 服务，而9000端口是上述gunicorn提供的端口    server_name   localhost;    client_max_body_size  50M;    #配置项目静态资源目录    location /static/ { ## /static/ 静态文件夹        #root /home/zhouguangyou/artproject/art; ##找到django的静态文件，这里找到项目的目录        root /home/dyl/SHDjangoLesson/; ##找到django的静态文件，这里找到项目的目录    }    location / {        proxy_pass   http://127.0.0.1:9000; ## 反向代理到9000端口        proxy_set_header  Host $host;        proxy_set_header  X-Real-IP  $remote_addr;        proxy_set_header  X-Forwarded-For $proxy_add_x_forwarded_for;     }    # error_page  404              /404.html;    # redirect server error pages to the static page /50x.html    #     error_page  500  502  503  504 /50x.html;     location = /50x.html {         root  html;      }}</code></pre><p>重启Nginx服务，生效。</p><p>通过以上的配置信息，基本已经完成了nginx + gunicorn + django的配置</p><p>测试：<a href="http://127.0.0.1:8000/，" target="_blank" rel="noopener">http://127.0.0.1:8000/，</a> 可以看到项目的效果图</p><p>5  安装Supervisor与配置</p><pre><code>supervisor管理进程，是通过fork/exec的方式将这些被管理的进程当作supervisor的子进程来启动，所以我们只需要将要管理进程的可执行文件的路径添加到supervisor的配置文件中就好了。此时被管理进程被视为supervisor的子进程，若该子进程异常终端，则父进程可以准确的获取子进程异常终端的信息，通过在配置文件中设置autostart=true，可以实现对异常中断的子进程的自动重启。</code></pre><p>（1）安装supervisor</p><p>(python3.6_env) zhouguangyou@ubuntu:~$ sudo apt install supervisor</p><p>上述方法我们直接管理gunicorn，让它启动和暂停，现在我们希望采用supervisor来管理gunicorn</p><p>（2）配置supervisor</p><p> 将supervisor设置为管理启动监控  gunicorn</p><p>产生配置文件supervisor.conf， 采用如下命令：</p><p>  echo_supervisord_conf &gt; supervisor.conf   ### 文件存放在deploy目录下</p><p>往supervisor.conf 中添加如下信息</p><pre><code>[group:artprojects]programs=art-1, art-2  ## 两个进程[program:art-1]##  路径-- 为了找到wsgi文件command=gunicorn --chdir /home/dyl/SHDjangoLesson/ SHDjangoLesson.wsgi:application  --bind 0.0.0.0:9001directory=/home/dyl/SHDjangoLesson  ##守护进程user=dylautorestart=true  #自动重启redirect_stderr=truestdout_logfile=log/art1.log # 文件日志，必须先创建文件，否则报错loglevel=info   #日志级别stopsignal=INT  #停止信号[program:art-2]command=gunicorn --chdir /home/dyl/SHDjangoLesson/ SHDjangoLesson.wsgi:application  --bind 0.0.0.0:9002directory=/home/dyl/SHDjangoLessonuser=dylautorestart=trueredirect_stderr=truestdout_logfile=log/art2.logloglevel=infostopsignal=INT[supervisord]  ## 守护进程nodaemon=false ## 后台执行logfile=log/supervisord.logpidfile=log/supervisord.pidloglevel=info</code></pre><p>创建log文件夹，存放日志文件  ，放在deploy下</p><p>在nginx配置文件project.conf中加入如下信息</p><pre><code>## upstream--- nginx和核心--- 反向代理 -- 一个端口对应一个进程upstream artprojects{    #ip_hash;  or  轮询（默认） or url_hash    server 127.0.0.1:9001; # 可以加权重 weight = 0 不分配    server 127.0.0.1:9002; # 这个可以是其他服务器的地址，就可以做到代理 } location / { #(2) method2: use proxy_pass upstream to the supervisor who manage the gunicorn      proxy_pass_header Server; ##Server nginx的变量      proxy_set_header Host $http_host;      #proxy_redirect off;      proxy_set_header X-Real-IP  $remote_addr; #真实Ip      proxy_set_header X-Scheme  $scheme;       #      proxy_pass  http://artprojects;   #反向代理，自动找upstream  }</code></pre><p>添加好上述配置信息后</p><p>（1）启动nginx</p><p>$ /opt/openresty/nginx/sbin/nginx</p><p>$ /opt/openresty/nginx/sbin/nginx -s reload    ## 重新加载– 热重启，不需要关闭nginx  （重启work进程，master不会重启）</p><p>$ /opt/openresty/nginx/sbin/nginx -t   ## 测试代码是否ok</p><p>nginx: the configuration file /opt/openresty/nginx/conf/nginx.conf syntax is ok</p><p>nginx: configuration file /ospt/openresty/nginx/conf/nginx.conf test is successful</p><p>（2）通过supervisor启动gunicorn</p><p>   supervisord -c supervisor.conf           需要在沙盒环境下启动！！内部是启动gunicorn                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                </p><p>页面通过<a href="http://127.0.0.1:8000/art/index进行页面访问，观看效果。" target="_blank" rel="noopener">http://127.0.0.1:8000/art/index进行页面访问，观看效果。</a></p><pre><code>综合上述，nginx做反向代理和负载均衡，将请求upstream转发给一个Supervisor监管的Gunicorn进程，而Gunicorn进程拖管了Django工程代码。</code></pre><p>至此，Nginx + Gunicorn + Supervisor + Django 线上环境部署都已经完成！ </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;1、项目代码打包部署&quot;&gt;&lt;a href=&quot;#1、项目代码打包部署&quot; class=&quot;headerlink&quot; title=&quot;1、项目代码打包部署&quot;&gt;&lt;/a&gt;1、项目代码打包部署&lt;/h2&gt;&lt;p&gt; 包压缩技巧：&lt;/p&gt;
&lt;p&gt; tar    -cjvf    python
      
    
    </summary>
    
      <category term="django" scheme="https://dyl521.github.io/categories/django/"/>
    
      <category term="python" scheme="https://dyl521.github.io/categories/django/python/"/>
    
    
      <category term="项目部署" scheme="https://dyl521.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>WEB的常识问题</title>
    <link href="https://dyl521.github.io/2016/09/10/ET%E5%92%8CPOST%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://dyl521.github.io/2016/09/10/ET和POST的区别/</id>
    <published>2016-09-10T13:55:00.000Z</published>
    <updated>2018-07-09T14:00:38.441Z</updated>
    
    <content type="html"><![CDATA[<h3 id="1、post和get的区别"><a href="#1、post和get的区别" class="headerlink" title="1、post和get的区别"></a>1、post和get的区别</h3><p>　　http定义了与服务器交互的不同方法，最基本的方法是： GET、POST、PUT、DELETE，对应增，删，改，查四个操作</p><p>根据HTTP规范，GET应当只用于数据的获取，安全的和等幂的<br>安全的意思是： 只用于数据的获取，不改变数据<br>等幂的意思是：任何人获取得到的数据是一样的<br>根据Http规范，POST表示可能改变服务端数据的请求</p><figure class="highlight sql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">'''</span><br><span class="line">    Http规范中：PUT、<span class="keyword">DELETE</span>、POST、<span class="keyword">GET</span> 对应资源的增删改查</span><br><span class="line">    </span><br><span class="line">    <span class="number">1</span>、<span class="keyword">Http</span>规范中，<span class="keyword">GET</span>用于数据的获取，并且是安全的，幂等的 </span><br><span class="line">        安全：不会对数据进行操作，只会查询</span><br><span class="line">        幂等：<span class="keyword">URL</span>多个请求返回的都是同一结果</span><br><span class="line">    <span class="number">2</span>、<span class="keyword">Http</span>规范中：POST表示可能会对数据进行更改</span><br><span class="line">    </span><br><span class="line">    <span class="number">3</span>、POST、<span class="keyword">GET</span>底层是TCP/IP,<span class="keyword">HTTP</span> 的底层也是TCP/IP</span><br><span class="line">        理论上，给<span class="keyword">GET</span>加上requestbody,给POST加上<span class="keyword">url</span>参数也是可以的</span><br><span class="line">        <span class="comment">---- 但是由于浏览器和编程人员没有约定的约定，才形成。。。HTTP</span></span><br><span class="line">        <span class="keyword">HTTP</span>没有要求，如果Method是POST数据就要放在<span class="keyword">BODY</span>中。也没有要求，如果Method是<span class="keyword">GET</span>，数据（参数）就一定要放在<span class="keyword">URL</span>中而不能放在<span class="keyword">BODY</span>中</span><br><span class="line">一般的答案：</span><br><span class="line"><span class="keyword">GET</span>：</span><br><span class="line">    <span class="keyword">GET</span> 请求可被缓存</span><br><span class="line">    <span class="keyword">GET</span> 请求保留在浏览器历史记录中</span><br><span class="line">    <span class="keyword">GET</span> 请求可被收藏为书签</span><br><span class="line">    <span class="keyword">GET</span> 请求不应在处理敏感数据时使用</span><br><span class="line">    <span class="keyword">GET</span> 请求有长度限制</span><br><span class="line">    <span class="keyword">GET</span> 请求只应当用于取回数据</span><br><span class="line">POST：</span><br><span class="line">    POST 请求不会被缓存</span><br><span class="line">    POST 请求不会保留在浏览器历史记录中</span><br><span class="line">    POST 不能被收藏为书签</span><br><span class="line">    POST 请求对数据长度没有要求</span><br><span class="line">        </span><br><span class="line">区别：</span><br><span class="line">    <span class="number">1</span>、数据存放位置：</span><br><span class="line">        <span class="keyword">GET</span>：会把请求的数据放在<span class="keyword">URL</span>之后，放在请求头中</span><br><span class="line">            存放的方式：？ 分割<span class="keyword">URL</span>和参数 参数之间用&amp;相连</span><br><span class="line">            如果数据是英文、数字，原样发送；若是空格转换为+；若是中文或其他字符，直接BASE64加密</span><br><span class="line">            如：%xx  xx表示<span class="number">16</span>进制表示的<span class="keyword">ascii</span></span><br><span class="line">        POST: 把请求的数据放在请求体中</span><br><span class="line">    <span class="number">2</span>、数据容量的大小：</span><br><span class="line">        <span class="keyword">Http</span>协议并没有规定，<span class="keyword">GET</span>或者POST数据的大小</span><br><span class="line">        <span class="keyword">GET</span>：  浏览器限制到<span class="number">1024</span>字节，限制是整个<span class="keyword">URL</span>的长度，<span class="keyword">URL</span>太长，考验服务器的处理能力</span><br><span class="line">        POST： 理论上没有限制，考验的是服务器的处理能力！！</span><br><span class="line">    <span class="number">3</span>、可见性、安全性：</span><br><span class="line">        <span class="keyword">GET</span>：所有人可见，在<span class="keyword">URL</span>中</span><br><span class="line">        POST：不可见，参数不会被保存在浏览器历史或 web 服务器日志中。</span><br><span class="line">    <span class="number">4</span>、最大的区别：</span><br><span class="line">        <span class="keyword">GET</span>产生一个TCP数据包：把请求头request header 和数据（<span class="keyword">URL</span>），一起发送出去，返回<span class="number">200</span> ok</span><br><span class="line">        POST产生两个TCP数据包：先发送请求头header，服务器响应<span class="number">100</span>（继续处理），再发送requestbody （数据），返回<span class="number">200</span></span><br><span class="line">        ## 并不是所有浏览器都会在POST中发送两次包，Firefox就只发送一次。！！</span><br><span class="line">        ## 网络环境好的情况下，发一次包的时间和发两次包的时间差别基本可以无视。而在网络环境差的情况下，两次包的TCP在验证数据包完整性上，有非常大的优点</span><br></pre></td></tr></table></figure><h3 id="2、Cookie和session的区别"><a href="#2、Cookie和session的区别" class="headerlink" title="2、Cookie和session的区别"></a>2、Cookie和session的区别</h3><p> 　　转自：<a href="https://www.cnblogs.com/tk55/p/6763809.html" target="_blank" rel="noopener">https://www.cnblogs.com/tk55/p/6763809.html</a></p><p>　　　　当一个客户端第一次连接的时候，就会给他一个cookie（身份证），下一次访问就会带这个cookie</p><p>　　但是，如果cookie单独使用的话，就会出现一个问题：当cookie过多，每次都会返回大量的数据—- 身份证，各种表格等等</p><p>　　　　session就是来解决这个问题的，session只需要取一次！！</p><p>　　　　cookie 保存session id ，每一次连接，cookie只需要带session id ，到服务器上取数据（增大了服务器的压力），就完成了—- 相当于现在只需要带身份证号</p><p>　　他们之间的共同之处是：都是用来跟踪浏览器确定用户的身份！</p><h3 id="3、状态码-定义"><a href="#3、状态码-定义" class="headerlink" title="3、状态码 定义"></a>3、状态码 定义</h3><p>1XX　　报告　　　　接收到请求，继续处理<br>2XX　　成功　　　　步骤成功接收，并且处理成功<br>3XX　　重定向　　　为完成请求，采进一个不措施<br>4XX                    客户端出错　不能完成，请求错误<br>5XX　　服务器错误 　服务器无法完成</p><h3 id="4、restful-API-开发"><a href="#4、restful-API-开发" class="headerlink" title="4、restful API 开发"></a>4、restful API 开发</h3><p>　　　　restful API 是后端人员编写的接口，让前端或者移动端使用的api接口</p><p>　　　　restful API 是一种软件设计风格和架构风格，值一种约束条件和原则，而不是规范<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">　　所谓资源就是在网络上存在的任意实体，哪怕是一条消息。</span><br><span class="line">操作：</span><br><span class="line">　　##cuda （create,read,update,delete）</span><br><span class="line"> 所谓操作就是对资源的CURD。在开发者设计良好的情况下，对网络资源的任意操作都可以抽象为对资源的CURD。</span><br><span class="line">Restful对网络资源的操作抽象为HTTP协议的GET、POST、PUT、DELETE等请求方法以完成对特定资源的增删改查操作</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;1、post和get的区别&quot;&gt;&lt;a href=&quot;#1、post和get的区别&quot; class=&quot;headerlink&quot; title=&quot;1、post和get的区别&quot;&gt;&lt;/a&gt;1、post和get的区别&lt;/h3&gt;&lt;p&gt;　　http定义了与服务器交互的不同方法，最基本的方
      
    
    </summary>
    
      <category term="django" scheme="https://dyl521.github.io/categories/django/"/>
    
    
      <category term="Web" scheme="https://dyl521.github.io/tags/Web/"/>
    
  </entry>
  
  <entry>
    <title>python中其他内置方法</title>
    <link href="https://dyl521.github.io/2016/08/15/thon%E4%B8%AD%E5%85%B6%E4%BB%96%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    <id>https://dyl521.github.io/2016/08/15/thon中其他内置方法/</id>
    <published>2016-08-15T05:07:00.000Z</published>
    <updated>2018-07-09T05:27:39.753Z</updated>
    
    <content type="html"><![CDATA[<p>1、抽象方法<br>　　抽象方法一般只用定义，不用实现；包含抽象方法的类不能直接创建对象，（包含抽象方法的称为抽象类）<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">## 抽象类必须导入的模块</span></span><br><span class="line"><span class="keyword">from</span> abc <span class="keyword">import</span> ABC,abstractmethod</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Stuent</span><span class="params">(ABC)</span>:</span></span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">run</span><span class="params">(self)</span>:</span> </span><br><span class="line"><span class="meta">    @abstractmethod</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">abstractMathod</span><span class="params">(self)</span>:</span></span><br><span class="line">      <span class="string">'''1、这是一个抽象方法，一般不写内容，只定义，不实现，由子类去实现</span></span><br><span class="line"><span class="string">        2、这个类包含抽象方法，就是抽象类，不能用来实例化对象     '''</span></span><br><span class="line"> <span class="comment"># ss = Stduent()  ##包含抽象方法的类，称为抽象类，不能直接实例化对象！！</span></span><br><span class="line"> <span class="comment">## 只能写个类，继承它，子类就能实例化对象</span></span><br><span class="line"> </span><br><span class="line"> <span class="class"><span class="keyword">class</span> <span class="title">ManStudent</span><span class="params">(Stduent)</span>:</span> </span><br><span class="line">     <span class="function"><span class="keyword">def</span> <span class="title">abstractMathod</span><span class="params">(self)</span>:</span>  <span class="comment">##抽象方法，重写</span></span><br><span class="line">         print(<span class="string">'abstractMathod'</span>) </span><br><span class="line"> ms = ManStudent()  <span class="comment">##重写父类方法后，就可以用子类实例化对象</span></span><br><span class="line"> ms.abstractMathod()</span><br></pre></td></tr></table></figure></p><a id="more"></a><p>2、其他内置方法<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> Student：</span><br><span class="line">    #__slots__：只有在列表的变量才能被添加在类里面</span><br><span class="line">      __slots__ = [<span class="string">'name,'</span>age<span class="string">''</span>,<span class="string">'height'</span>]     </span><br><span class="line">    def __init__(self):</span><br><span class="line">        self.name = <span class="string">''</span></span><br><span class="line">        self.age = <span class="number">0</span></span><br><span class="line">        #self.weight = <span class="number">0</span>##不能添加，因为上面列表中不存在</span><br><span class="line">s = Student()</span><br><span class="line"># s.weight =<span class="number">10</span> ##在类的外面同样不可以添加</span><br><span class="line"></span><br><span class="line">print(Student.__name__)  ##获取类名，得到字符串</span><br><span class="line">print(Student.__bases__) ##得到类的所有父类，返回元祖，所有类默认继承object类</span><br><span class="line">print(Student.__dict__)     ##得到类里面的所有信息，返回字典</span><br></pre></td></tr></table></figure></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;1、抽象方法&lt;br&gt;　　抽象方法一般只用定义，不用实现；包含抽象方法的类不能直接创建对象，（包含抽象方法的称为抽象类）&lt;br&gt;&lt;figure class=&quot;highlight python&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;3&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;4&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;5&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;6&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;7&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;8&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;9&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;10&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;11&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;12&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;13&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;14&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;15&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;16&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;17&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;comment&quot;&gt;## 抽象类必须导入的模块&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;from&lt;/span&gt; abc &lt;span class=&quot;keyword&quot;&gt;import&lt;/span&gt; ABC,abstractmethod&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;Stuent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(ABC)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;    @abstractmethod&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;    &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;abstractMathod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;      &lt;span class=&quot;string&quot;&gt;&#39;&#39;&#39;1、这是一个抽象方法，一般不写内容，只定义，不实现，由子类去实现&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;string&quot;&gt;        2、这个类包含抽象方法，就是抽象类，不能用来实例化对象     &#39;&#39;&#39;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;# ss = Stduent()  ##包含抽象方法的类，称为抽象类，不能直接实例化对象！！&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;comment&quot;&gt;## 只能写个类，继承它，子类就能实例化对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; &lt;span class=&quot;class&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;ManStudent&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(Stduent)&lt;/span&gt;:&lt;/span&gt; &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;     &lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;def&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;abstractMathod&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(self)&lt;/span&gt;:&lt;/span&gt;  &lt;span class=&quot;comment&quot;&gt;##抽象方法，重写&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;         print(&lt;span class=&quot;string&quot;&gt;&#39;abstractMathod&#39;&lt;/span&gt;) &lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ms = ManStudent()  &lt;span class=&quot;comment&quot;&gt;##重写父类方法后，就可以用子类实例化对象&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt; ms.abstractMathod()&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="python" scheme="https://dyl521.github.io/categories/python/"/>
    
    
      <category term="python内置方法" scheme="https://dyl521.github.io/tags/python%E5%86%85%E7%BD%AE%E6%96%B9%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python中的进程线程协程</title>
    <link href="https://dyl521.github.io/2016/08/12/python%E4%B8%AD%E7%9A%84%E8%BF%9B%E7%A8%8B%E7%BA%BF%E7%A8%8B%E5%8D%8F%E7%A8%8B/"/>
    <id>https://dyl521.github.io/2016/08/12/python中的进程线程协程/</id>
    <published>2016-08-12T04:37:00.000Z</published>
    <updated>2018-07-09T04:40:46.690Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://www.cnblogs.com/zhang-can/p/7215506.html" target="_blank" rel="noopener">https://www.cnblogs.com/zhang-can/p/7215506.html</a><br><a href="http://cenalulu.github.io/python/gil-in-python/" target="_blank" rel="noopener">http://cenalulu.github.io/python/gil-in-python/</a></p><p>1、啥是进程？<br>　　进程是计算机中程序关于数据集合的一次活动，是操作系统进行资源分配和调度的基本单位</p><p>　　进程也可以描述是一个程序在一个数据就上一次动态执行过程。<br>　　进程的调度是由操作系统决定的！<br>　　在一台计算机上，可以打开的进程是有限的，不能过多，否则操作系统业务无法进行调度！！<br><a id="more"></a><br>2、啥是线程？<br>　　一个进程，可以有好多个线程，在同一个进程中，多个线程共享同一内存。线程是CPU执行的基本单元</p><p>　　一个进程中，至少有一个主线程，一个主进程。在python中，用threading，开启子线程。至于效率的问题，后面再说</p><p>　　标准的线程调度也是由操作系统来调度的</p><p>3、啥是协程？<br>　　协程的最大特点，是完全是由用户自己控制，不需要内核态的切换。协程避免了无意义的调度，由此可以提高性能，调度由代码来控制</p><p>协程可以通过yield来调度其他的协程，调用一次返回一个协程，迭代器的实现</p><p>4、进程线程的区别<br>　　（1）一个线程只属于一个进程，而一个进程可以有多个线程，但是至少有一个主线程</p><p>　　（2）资源分配给进程，进程是程序的主体，同一进程的线程共享该线程的内存等所有源</p><p>　　（3）CPU分配给线程，即真正在CPU上运行的是线程</p><p>　　（4）线程是执行的最小执行单位，进程最小的资源管理单位</p><p>5、啥是GIL锁？<br>　　Python GIL(Global Interpreter Lock)<br>　　In CPython, the global interpreter lock, or GIL, is a mutex that prevents multiple native threads from executing Python bytecodes at once. This lock is necessary mainly because CPython’s memory management is not thread-safe. (However, since the GIL exists, other features have grown to depend on the guarantees that it enforces.) [python分为Cpython、Jpython、pypy等，但是Jpython中biang没有GIL锁，人们常说的python是Cpython，所以python可以不依赖GIL，也可以执行]</p><p>上面的核心意思就是，无论你启多少个线程，你有多少个cpu, Python在执行的时候会淡定的在同一时刻只允许一个线程运行，擦。。。，那这还叫什么多线程呀？莫如此早的下结结论，听我现场讲。</p><p>（1）为啥python要保证同一时刻只允许一个线程运行？</p><p>　　　　为了利用多核的能力，python才引入了GIL的机制来加锁（保护线程间的同步和状态的一致），正是因为GIL锁，所以python的线程是安全的（我们在实现的时候无需考虑内存锁和同步操作）。后来开发人员，发现了这个巨大的bug，但是大量的开发已经依赖了。无法直接去掉，只能慢慢优化。。</p><p>（2）怎样避免受到GIL的影响？</p><p>　　我们应该考虑到我们实际的应用场景，主要有两种：</p><p>CPU密集型：大量的计算，如视频处理，科学计算等等。这样的情况下，我们使用多进程模式（multiprocessing模块），因为多个进程之间有不同的GIL锁，相互之间不会影响<br>　　　　若是还想进一步提高，那么我们可以将中间的耗时代码换成为C语言执行！</p><p>　　2. IO密集型：大量的输入输出处理，如网络，文件读写、web等等，这样的情况使用多线程（threading模块）+协程的方式！</p><p>6、进程实现<br>　　multiprocessing模块</p><p>7、线程实现<br>　　threading 模块</p><p>8、协程实现<br>　　yield、greenlet、gevent模块</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;https://www.cnblogs.com/zhang-can/p/7215506.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;https://www.cnblogs.com/zhang-can/p/7215506.html&lt;/a&gt;&lt;br&gt;&lt;a href=&quot;http://cenalulu.github.io/python/gil-in-python/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;http://cenalulu.github.io/python/gil-in-python/&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;1、啥是进程？&lt;br&gt;　　进程是计算机中程序关于数据集合的一次活动，是操作系统进行资源分配和调度的基本单位&lt;/p&gt;
&lt;p&gt;　　进程也可以描述是一个程序在一个数据就上一次动态执行过程。&lt;br&gt;　　进程的调度是由操作系统决定的！&lt;br&gt;　　在一台计算机上，可以打开的进程是有限的，不能过多，否则操作系统业务无法进行调度！！&lt;br&gt;
    
    </summary>
    
      <category term="python" scheme="https://dyl521.github.io/categories/python/"/>
    
    
      <category term="进程" scheme="https://dyl521.github.io/tags/%E8%BF%9B%E7%A8%8B/"/>
    
      <category term="线程" scheme="https://dyl521.github.io/tags/%E7%BA%BF%E7%A8%8B/"/>
    
      <category term="协程" scheme="https://dyl521.github.io/tags/%E5%8D%8F%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>Linux基础</title>
    <link href="https://dyl521.github.io/2016/08/10/Linux%E5%9F%BA%E7%A1%80/"/>
    <id>https://dyl521.github.io/2016/08/10/Linux基础/</id>
    <published>2016-08-10T13:51:00.000Z</published>
    <updated>2018-07-08T13:52:57.899Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h1><p>1991年，芬兰的一个研究生linus trovslds（李纳斯脱袜子）购买了自己的第一台电脑，并且决定开始开发自己的操作系统。这个想法非常的偶然，最初只是为了满足自己读写新闻和邮件的需求。他选择了minix作为自己的研究对象。而minix是一个开放的模型操作系统。最终取名为 linux（linus 的 minix），最终在全世界形成了巨大的回响。<br><a id="more"></a><br>优点</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="number">1</span>、开源免费</span><br><span class="line"><span class="number">2</span>、多用户、多任务</span><br><span class="line"><span class="number">3</span>、良好的界面（图形化界面、字符界面）</span><br><span class="line">Ubuntu、deepin(中国开发的)</span><br></pre></td></tr></table></figure><p>版本号说明</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">输入指令查看   uname -r</span><br><span class="line"><span class="number">2.6</span><span class="number">.32</span><span class="number">-642.</span>el6.x86_64</span><br><span class="line">linux的内核版本分为两种：一种叫做开发版，一种是稳定版</span><br><span class="line"><span class="number">2</span>：内核主版本</span><br><span class="line"><span class="number">6</span>：奇数代表开发版，偶数代表稳定版，小版本号</span><br><span class="line"><span class="number">32</span>：该版本修复的次数</span><br></pre></td></tr></table></figure><p>发行版本</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">常见的linux系统，只要是基于linux内核的系统都称之为linux的发行版本</span><br><span class="line">发行版本有很多，不同的发行版本基本指令都是一样的，软件安装方式不一样</span><br><span class="line">Debian（大便系列）</span><br><span class="line">Gentoo（贱兔系列）</span><br><span class="line">Ubuntu（乌班图），是大便系列的衍生版</span><br><span class="line">RedHat（红帽系列）</span><br><span class="line">CentOS  是红帽系列的发行版本</span><br></pre></td></tr></table></figure><h1 id="安装系统"><a href="#安装系统" class="headerlink" title="安装系统"></a>安装系统</h1><p>首先在下载centos7.2之前，我们需要一个容器，我们使用VMware，我们使用破解版。</p><p>vmware是收费的，但是我们使用的是破解版的。</p><p>打开VMware</p><p>点击创建虚拟机 -&gt; 选择自定义 -&gt; 下一步 -&gt; 稍后安装操作系统 -&gt; 点击Linux 选择CentOS 64位 -&gt; 名字自己取 位置自己选 -&gt; 处理器核心数量1核就够了 -&gt; 内存1024MB -&gt; 使用桥接网络 -&gt; 下一步 -&gt; 下一步 -&gt; 下一步 -&gt; 磁盘大小自己分配   将磁盘存储为单个文件 -&gt; 下一步 -&gt; 完成</p><p>现在centOS的容器就创建完毕了</p><p>右键选择容器的设置-&gt;找到CD/DVD-&gt;选择 使用ISO映像文件 然后找到.iso文件就可以了。</p><p>然后就可以点击开机就可以安装了。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">开机以后直接选择install centos <span class="number">7</span></span><br><span class="line"></span><br><span class="line">test this media &amp; install centos <span class="number">7</span>是先测试镜像有误错误在安装</span><br><span class="line"></span><br><span class="line">Troubleshoopting 是用来测试内存和启动救援模式修复已经存在的centos。</span><br><span class="line"></span><br><span class="line">随后进入到了语言选择的界面：选择中文提示，点击<span class="keyword">continue</span></span><br><span class="line"></span><br><span class="line">安装程序需要用户设置信息分为三个部分：本地化、软件和系统，完成这些配置可以继续安装</span><br><span class="line"></span><br><span class="line">时区 我们使用默认的 亚洲/上海 </span><br><span class="line">键盘 就是汉语</span><br><span class="line">语言 中文</span><br><span class="line"></span><br><span class="line">注意：即使是英文作为默认语言，也因该安装中文支持，否则一些中文文件无法正常的去显示。</span><br><span class="line"></span><br><span class="line">最小安装只安装系统最基本的组件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">安装位置：</span><br><span class="line">我们默认只有一个硬盘区域，我们在网络开启后，可以选择添加硬盘来增加额外的存储空间。</span><br><span class="line"></span><br><span class="line">最后在其它存储选项中，可以选择手动分区和系统是否加密。选择“我要配置分区”然后点击完成。</span><br><span class="line"></span><br><span class="line">这个时候会进入到手动分区的页面。</span><br><span class="line"></span><br><span class="line">点击下方的“+”添加分区</span><br><span class="line"></span><br><span class="line">第一项挂载点就是系统目录。第二项是期望容量，这里的默认单位是MB，你也可以写<span class="number">2</span>GB、<span class="number">100</span>MB。</span><br><span class="line"></span><br><span class="line">依次添加挂载点为“/boot”的引导分区，空间为<span class="number">1024</span>MB。</span><br><span class="line">载点为“swap”，分<span class="number">2</span>GB。</span><br><span class="line">最后一个挂载点“/”，不写默认把剩下的空间全部分配过去。</span><br><span class="line"></span><br><span class="line">然后点击完成 接受更改</span><br><span class="line"></span><br><span class="line">最后我们配置网络和主机名</span><br><span class="line"></span><br><span class="line">点击进去以后看到“eno16777736”的网卡是关闭状态的,将它打开</span><br><span class="line"></span><br><span class="line">在左下角看到“localhost.localdomain”，我将主机名改成我自己的名字</span><br><span class="line"></span><br><span class="line">如果网络还需要配置IP地址信息的，可以单点配置按钮，在弹出的窗口中选着“IPV4设置”，可以看到系统默认使用DHCP的方式自动回去IP地址。</span><br><span class="line"></span><br><span class="line">如果需要设置IP地址可以在方法中选择手动，然后添加相应的IP、子网掩码和网关。DNS服务器地址应该填写在“附加DNS服务区”选项中，如果有多个DNS需要使用逗号割开。点击完成。</span><br><span class="line"></span><br><span class="line">确认无误以后点击“开始安装”</span><br><span class="line"></span><br><span class="line">然后可以看见root密码。root用户通常称为根用户，在linux系统中拥有最高权限。root密码一般要设置安全级别高一些的。</span><br><span class="line"></span><br><span class="line">由于root用户的权限太高，分给每一个管理员的时候，可能会出现一些不必要的问题和麻烦。</span><br><span class="line"></span><br><span class="line">点击创建用户，输入用户名和密码，我们现在是学习阶段，可以分配管理员权限。一般不给管理员权限，必要的时候向root用户申请权限。</span><br><span class="line"></span><br><span class="line">安装完毕以后点击重启</span><br></pre></td></tr></table></figure><h2 id="为什么使用CentOS7了？和6版本有什么不同"><a href="#为什么使用CentOS7了？和6版本有什么不同" class="headerlink" title="为什么使用CentOS7了？和6版本有什么不同"></a>为什么使用CentOS7了？和6版本有什么不同</h2><p>centos7与6之间最大的差别就是初始化技术的不同，==7采用的初始化技术是Systemd,并行的运行方式==，除了这一点之外，服务启动、开机启动文件、网络命令方面等等，都说6有所不同。让我们先来了解一下系统初始化技术的演变过程。</p><h3 id="1-系统初始化技术"><a href="#1-系统初始化技术" class="headerlink" title="1.系统初始化技术"></a>1.系统初始化技术</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">Sysvinit技术</span><br><span class="line">Upstart技术</span><br><span class="line">Systemd技术</span><br><span class="line"></span><br><span class="line">Sysvinit技术</span><br><span class="line"></span><br><span class="line">特点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>系统第<span class="number">1</span>个进程为init;</span><br><span class="line"><span class="number">2.</span>init进程是所有进程的父进程，不可kill；</span><br><span class="line"><span class="number">3.</span>大多数Linux发行版的init系统是和SystemV相兼容的，被称为sysvinit</span><br><span class="line"><span class="number">4.</span>代表系统：CentOS5 CentOS6</span><br><span class="line"></span><br><span class="line">优点：</span><br><span class="line"></span><br><span class="line">sysvinit运行非常良好，概念简单清晰。它主要依赖于shell脚本。</span><br><span class="line"></span><br><span class="line">缺点：</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span>按照一定顺序执行——&gt;启动太慢。</span><br><span class="line"><span class="number">2.</span>很容易hang住，fstab与nfs挂载问题</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Upstart技术</span><br><span class="line"></span><br><span class="line">CentOS6采用了upstart技术代替sysVinit进行引导，Upstart对rc.sysinit脚本做了大量的优化，缩短了系统初始化的启动时间。但是CentOS6为了简便管理员的操作，upstart的很多特性并没有凸显或直接不支持。</span><br></pre></td></tr></table></figure><p>代表系统：CentOS6, Ubuntu14, 从CentOS7, Ubuntu15开始使用systemd</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Systemd技术</span><br><span class="line"></span><br><span class="line">新系统都会采用的技术（RedHat7,CentOS7,Ubuntu15等）；</span><br><span class="line">设计目标是克服sysvinit固有的缺点，提高系统的启动速度；</span><br><span class="line">和Sysvinit兼容，降低迁移成本；</span><br><span class="line">最主要优点：并行启动</span><br><span class="line">Pid为<span class="number">1</span>的进程</span><br></pre></td></tr></table></figure><h3 id="2-在yum源上的优化"><a href="#2-在yum源上的优化" class="headerlink" title="2.在yum源上的优化"></a>2.在yum源上的优化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">在centos6的时候，默认是从官方源下载rpm包的，由于是国外的yum源很慢不能用，CentOS7在这里做了优化，当我们使用yum安装软件的时候，默认不会再从官方下载，而是自动寻找离自己地理位置最近的yum源开始下载。</span><br></pre></td></tr></table></figure><h3 id="3-命令"><a href="#3-命令" class="headerlink" title="3.命令"></a>3.命令</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">如果在安装系统的时候选择minimal，会比之前<span class="number">6</span>的时候以更小的包来安装，比如：vim、ifconfig、route、setup、netstat等等很多命令都没有了。。在安装系统后可加入以下软件包：</span><br><span class="line"></span><br><span class="line">yum install lrzsz tree net-tools nmap vim bash-completion lsof dos2unix nc telnet ntp wget rng-tools psmisc screen -y</span><br></pre></td></tr></table></figure><p>比如ifconfig是查看网卡信息的，centos7中没有，那么我们使用</p><p>​    yum安装<code>net-tools</code>来提供一些网络的命令。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">bash-completion 自动命令补全的工具</span><br><span class="line"></span><br><span class="line">psmisc 这个包含有killall命令。</span><br><span class="line"> </span><br><span class="line">screen 可以新建一个窗口，把任务放在后台运行。</span><br><span class="line"></span><br><span class="line">rng-tools   生成随机数嫡池的一个工具，有了这个工具tomcat 启动会变得非常快</span><br><span class="line"></span><br><span class="line">lrzsz 支持windowns平台的上传下载linux。在windowns远程连接工具上可以使用。</span><br></pre></td></tr></table></figure><h3 id="4-字符集修改"><a href="#4-字符集修改" class="headerlink" title="4.字符集修改"></a>4.字符集修改</h3><p>centos6的时候修改字符集：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/locale.conf  <span class="comment">#字符集配置文件</span></span><br><span class="line">localectl set-locale LANG=zh_CN.UTF<span class="number">-8</span></span><br></pre></td></tr></table></figure><p>而centos7只需要一行命令搞定</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">localectl set-locale LANG=zh_CN.UTF<span class="number">-8</span></span><br><span class="line"></span><br><span class="line">localectl status</span><br></pre></td></tr></table></figure><h3 id="5-开机启动管理"><a href="#5-开机启动管理" class="headerlink" title="5.开机启动管理"></a>5.开机启动管理</h3><p>centos6依靠<code>/etc/rc.local</code>对开机启动进行管理的，但是这个文件的权限是开放的。</p><p>而centos7</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/etc/rc.local  <span class="comment"># 这个文件还是存在，不过如果我们还想继续使用这种方式需要给它加执行权限chmod +x /etc/rc.d/rc.local</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># system一统天下 snapshot(支持快照)</span></span><br><span class="line"></span><br><span class="line">systemctl status cron.service <span class="comment">#查看定时任务状态</span></span><br><span class="line">systemctl stop cron.service   <span class="comment">#关闭定时任务</span></span><br><span class="line">systemctl status cron.service  <span class="comment">#查看操作情况</span></span><br><span class="line">systemctl  list-unit-files|grep enable  <span class="comment">#查看当前正在运行的服务</span></span><br><span class="line">systemctl   disable postfix.service <span class="comment">#关闭邮件服务</span></span><br><span class="line">systemctl  list-unit-files|grep postfix <span class="comment">#查看邮件服务是否开启</span></span><br><span class="line">systemctl stop firewalld.service <span class="comment">#关闭防火墙</span></span><br><span class="line">systemctl  <span class="keyword">is</span>-enable <span class="comment">#开启的服务 </span></span><br><span class="line">systemctl  disable   <span class="comment">#关闭的服务</span></span><br></pre></td></tr></table></figure><p>centos7 通过/etc/rc.d/rc.local/开机自启动</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">centos7中/etc/rc.d/rc.local需要执行如下命令赋予可执行权限</span><br><span class="line">chmod +x /etc/rc.d/rc.local</span><br></pre></td></tr></table></figure><h3 id="6-运行级别runlevel"><a href="#6-运行级别runlevel" class="headerlink" title="6.运行级别runlevel"></a>6.运行级别runlevel</h3><p>centos6   “/etc/inittab” 在centos7中是无效的。</p><p>centos7  system target 替代 了inittab</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">##永久生效下次登录生效</span></span><br><span class="line">systemctl get-default graphical.target 切换到<span class="number">5</span></span><br><span class="line">systemctl get-default multi-user.target 切换到<span class="number">3</span></span><br><span class="line"><span class="comment">##临时生效的话 </span></span><br><span class="line">init3</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment">#查看运行级别</span></span><br><span class="line">ls -lh /usr/lib/systemd/system/runlevel*.target</span><br></pre></td></tr></table></figure><p>运行级别（Runlevel）指的是Unix或者Linux等类Unix操作系统下不同的运行模式。运行级别通常分为7等，分别是从0到6，但如果必要的话也可以更多。</p><p>例如在大多数linux操作系统下一共有如下6个典型的运行级别：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0</span> 停机</span><br><span class="line"><span class="number">1</span> 单用户，Does <span class="keyword">not</span> configure network interfaces, start daemons, <span class="keyword">or</span> allow non-root logins</span><br><span class="line"><span class="number">2</span> 多用户，无网络连接 Does <span class="keyword">not</span> configure network interfaces <span class="keyword">or</span> start daemons</span><br><span class="line"><span class="number">3</span> 多用户，启动网络连接 Starts the system normally.</span><br><span class="line"><span class="number">4</span> 用户自定义</span><br><span class="line"><span class="number">5</span> 多用户带图形界面</span><br><span class="line"><span class="number">6</span> 重启</span><br></pre></td></tr></table></figure><h2 id="ssh进行访问"><a href="#ssh进行访问" class="headerlink" title="ssh进行访问"></a>ssh进行访问</h2><p>windows下安装xshell来进行可以远程访问。</p><p>而mac 是用ssh命令 </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ssh 用户名@ip地址:端口号</span><br><span class="line"></span><br><span class="line">默认的端口号<span class="number">22</span>可以不写</span><br><span class="line">ssh root@<span class="number">172.11</span><span class="number">.11</span><span class="number">.96</span></span><br></pre></td></tr></table></figure><p>首先我们先下载‘net-tools’，这样可以使用ifconfig查看网卡信息，它的作用和DOS命令ipconfig一样。</p><p>下载完成以后输入：ifconfig</p><p>然后可以找到你的ip地址</p><p>如果ssh链接被拒绝：</p><p>1.验证openssh-server<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">首先，要确保CentOS7安装了  openssh-server，在终端中输入</span><br><span class="line"></span><br><span class="line">yum list installed | grep openssh-server</span><br><span class="line"></span><br><span class="line">如果出现了结果那么表示已经安装</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">没有安装输入</span><br><span class="line"></span><br><span class="line">yum install openssh-server -y</span><br></pre></td></tr></table></figure></p><p>2.配置你的ssh文件</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line">找到了  /etc/ssh/  目录下的sshd服务配置文件 sshd_config，用Vim编辑器打开</span><br><span class="line"></span><br><span class="line">如果没有vim编辑器那么执行：</span><br><span class="line"></span><br><span class="line">yum install vim -y</span><br><span class="line"></span><br><span class="line">vim编辑器比vi编辑器增加了颜色识别</span><br><span class="line"></span><br><span class="line">vim /etc/ssh/sshd_config</span><br><span class="line"></span><br><span class="line">直接输入/Port </span><br><span class="line"></span><br><span class="line">可以看见：</span><br><span class="line">================</span><br><span class="line"><span class="number">1.</span>将文件中，关于监听端口、监听地址前的 <span class="comment"># 号去除</span></span><br><span class="line"></span><br><span class="line">Port <span class="number">22</span></span><br><span class="line"><span class="comment">#AddressFamily any</span></span><br><span class="line">ListenAddress <span class="number">0.0</span><span class="number">.0</span><span class="number">.0</span> <span class="comment">#任意地址</span></span><br><span class="line">ListenAddress ::</span><br><span class="line">================</span><br><span class="line">去上面<span class="number">3</span>行的注释</span><br><span class="line"></span><br><span class="line">要想编辑的话需要按键盘i，代表insert，取消输入按esc</span><br><span class="line"></span><br><span class="line">================</span><br><span class="line"><span class="number">2.</span>然后开启允许远程登录</span><br><span class="line">PermitRootLogin yes</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line">================</span><br><span class="line"><span class="number">3.</span>开启使用用户名密码来作为连接验证</span><br><span class="line">PasswordAuthentication yes</span><br><span class="line">================</span><br><span class="line"></span><br><span class="line">最后保证在取消输入的状态下</span><br><span class="line">输入</span><br><span class="line">================</span><br><span class="line">：wq! </span><br><span class="line">================</span><br><span class="line">代表强制保存退出</span><br><span class="line"></span><br><span class="line">配置完成后需要重新启动一下sshd服务</span><br><span class="line"></span><br><span class="line">开启  sshd  服务，输入 sudo service sshd start</span><br><span class="line">检查  sshd  服务是否已经开启，输入ps -e | grep sshd</span><br><span class="line">或者输入netstat -an | grep <span class="number">22</span>  检查  <span class="number">22</span> 号端口是否开启监听</span><br></pre></td></tr></table></figure><p>##简单操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">ifconfig    查看ip地址</span><br><span class="line">ping  ip地址     用来测试网络是否联通</span><br><span class="line">通过ctrl + c 来停止这个进程</span><br><span class="line">ls </span><br><span class="line">显示当前文件夹（目录）下面的所有文件</span><br><span class="line">pwd</span><br><span class="line">显示当前目录的路径</span><br><span class="line">根目录   /</span><br><span class="line">cd   目录的路径</span><br><span class="line">切换到指定目录</span><br><span class="line">绝对路径、相对路径</span><br><span class="line">绝对路径：相对于根目录的路径</span><br><span class="line">相对路径：相对于当前目录的路径</span><br><span class="line">.       : 代表的就是当前目录</span><br><span class="line">..      ：代表的就是上一级目录</span><br><span class="line">cd      : 直接来到家目录下面</span><br><span class="line">cd -    : 回到之前的目录（回看）</span><br><span class="line">[root@localhost /]<span class="comment">#</span></span><br><span class="line">root：当前用户名</span><br><span class="line">localhost：主机名</span><br><span class="line">/：   当前所在目录</span><br><span class="line"><span class="comment">#：   代表超级管理员在执行指令</span></span><br><span class="line">$:    代表普通管理员在执行指令</span><br><span class="line">拍快照（恢复到快照）</span><br><span class="line">纯净水系统</span><br><span class="line">tab键（自动补全）</span><br><span class="line">指令和路径都可以自动补全</span><br><span class="line"></span><br><span class="line">clear 清理屏幕·</span><br><span class="line">目录：</span><br><span class="line">/：根目录</span><br><span class="line">~: 家目录（就是你可以肆意妄为的地方）</span><br><span class="line">linux每一个用户都有一个家目录，那意思就是说你这个用户在你的家目录下面拥有至高无上的权限</span><br><span class="line">root的家目录就在   /root</span><br><span class="line">普通用户的家目录在   /home/ruidong   </span><br><span class="line">. ：当前目录</span><br><span class="line">..  ：上一级目录    cd ../../（上一级的上一级）</span><br></pre></td></tr></table></figure><p>##指令</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">关机：poweroff   halt   </span><br><span class="line">shutdown  now</span><br><span class="line">shutdown -h +<span class="number">5</span>   <span class="string">'woyaoguanjile'</span>    <span class="number">5</span>分钟之后关机</span><br><span class="line">shutdown -h <span class="number">16</span>:<span class="number">10</span>    下午<span class="number">4</span>点<span class="number">10</span>分关机</span><br><span class="line">重启：reboot   </span><br><span class="line">shutdown -r now</span><br><span class="line">date</span><br><span class="line">查看当前时间日期</span><br><span class="line">cal</span><br><span class="line">查看当月日历</span><br><span class="line">cal <span class="number">8</span> <span class="number">2017</span>   查看<span class="number">2017</span>年<span class="number">8</span>月的日历</span><br><span class="line">cal <span class="number">2017</span>     查看<span class="number">2017</span>年所有的日历</span><br><span class="line">上下方向按键</span><br><span class="line">快速的调出历史指令</span><br></pre></td></tr></table></figure><h4 id="防火墙管理"><a href="#防火墙管理" class="headerlink" title="防火墙管理"></a>防火墙管理</h4><p><a href="https://blog.csdn.net/achang21/article/details/52538049" target="_blank" rel="noopener">https://blog.csdn.net/achang21/article/details/52538049</a></p><h4 id="centos安装vm-tools"><a href="#centos安装vm-tools" class="headerlink" title="centos安装vm-tools"></a>centos安装vm-tools</h4><p><a href="https://www.linuxidc.com/Linux/2017-05/143323.htm" target="_blank" rel="noopener">https://www.linuxidc.com/Linux/2017-05/143323.htm</a></p><p>命令：</p><p> sudo netstat -apn | grep 80  ## 查看端口是否有服务</p>]]></content>
    
    <summary type="html">
    
      &lt;hr&gt;
&lt;h1 id=&quot;简述&quot;&gt;&lt;a href=&quot;#简述&quot; class=&quot;headerlink&quot; title=&quot;简述&quot;&gt;&lt;/a&gt;简述&lt;/h1&gt;&lt;p&gt;1991年，芬兰的一个研究生linus trovslds（李纳斯脱袜子）购买了自己的第一台电脑，并且决定开始开发自己的操作系统。这个想法非常的偶然，最初只是为了满足自己读写新闻和邮件的需求。他选择了minix作为自己的研究对象。而minix是一个开放的模型操作系统。最终取名为 linux（linus 的 minix），最终在全世界形成了巨大的回响。&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://dyl521.github.io/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://dyl521.github.io/tags/centos/"/>
    
  </entry>
  
  <entry>
    <title>Samba环境搭建</title>
    <link href="https://dyl521.github.io/2016/07/22/mba%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/"/>
    <id>https://dyl521.github.io/2016/07/22/mba环境搭建/</id>
    <published>2016-07-22T13:54:00.000Z</published>
    <updated>2018-07-08T13:58:17.488Z</updated>
    
    <content type="html"><![CDATA[<h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>samba主要运用与windows电脑与linux主机之间进行文件共享</p><p>软硬件环境<br><a id="more"></a><br>linux 主机s1一台，关闭selinux和防火墙，192.168.199.236</p><p>windows主机 c1一台，192.168.199.2</p><p>搭建之前：关闭防火墙和selinux service iptables stop setenforce 0</p><p>操作步骤</p><p>在s1上面安装samba服务</p><p>yum install -y samba samba-client    #安装samba服务端与客户端<br>编辑samba的配置文件，/etc/samba/smb.conf</p><p>[global]                    #全局的配置<br>        workgroup = MYGROUP    #window里面的工作组，默认是WORKGROUP<br>        server string = Samba Server Version %v<br>        security = user<br>        passdb backend = tdbsam<br>        load printers = yes<br>        cups options = raw<br>[homes]    #模块的配置<br>        comment = Home Directories<br>        browseable = no<br>        writable = yes<br>[printers]    #模块的配置<br>        comment = All Printers<br>        path = /var/spool/samba<br>        browseable = no<br>        guest ok = no<br>        writable = no<br>        printable = yes<br>[global] 定义全局的配置，workgroup用来定义工作组，相信如果你安装过windows的系统，你会对这个workgroup不陌生。一般情况下，需要我们把这里的MYGROUP改成WORKGROUP（windows默认的工作组名字）。</p><p>security = user #这里指定samba的安全等级。关于安全等级有四种：</p><p>share：用户不需要账户及密码即可登录samba服务器</p><p>user：由提供服务的samba服务器负责检查账户及密码（默认）</p><p>server：检查账户及密码的工作由另一台windows或samba服务器负责</p><p>domain：指定windows域控制服务器来验证用户的账户及密码。</p><p>passdb backend = tdbsam # passdb backend（用户后台），samba有三种用户后台：smbpasswd, tdbsam和ldapsam.</p><p>smbpasswd：该方式是使用smb工具smbpasswd给系统用户（真实用户或者虚拟用户）设置一个Samba密码，客户端就用此密码访问Samba资源。smbpasswd在/etc/samba中，有时需要手工创建该文件。</p><p>tdbsam：使用数据库文件创建用户数据库。数据库文件叫passdb.tdb，在/etc/samba中。passdb.tdb用户数据库可使用 smbpasswd -a 创建Samba用户，要创建的Samba用户必须先是系统用户。也可使用pdbedit创建Samba账户。pdbedit参数很多，列出几个主要的：</p><p>pdbedit -a username：新建Samba账户。</p><p>pdbedit -x username：删除Samba账户。</p><p>pdbedit -L：列出Samba用户列表，读取passdb.tdb数据库文件。</p><p>pdbedit -Lv：列出Samba用户列表详细信息。</p><p>pdbedit -c “[D]” -u username：暂停该Samba用户账号。</p><p>pdbedit -c “[]” -u username：恢复该Samba用户账号。</p><p>ldapsam：基于LDAP账户管理方式验证用户。首先要建立LDAP服务，设置 “passdb backend = ldapsam:ldap://LDAP Server”</p><p>load printers 和 cups options 两个参数用来设置打印机相关。</p><p>除了这些参数外，还有几个参数需要你了解：</p><p>netbios name = MYSERVER # 设置出现在网上邻居中的主机名</p><p>hosts allow = 127. 192.168.12. 192.168.13. # 用来设置允许的主机，如果在前面加 ”;” 则表示允许所有主机</p><p>log file = /var/log/samba/%m.log #定义samba的日志，这里的%m是上面的netbios name</p><p>max log size = 50 # 指定日志的最大容量，单位是K</p><p>[homes] 该部分内容共享用户自己的家目录，也就是说，当用户登录到samba服务器上时实际上是进入到了该用户的家目录，用户登陆后，共享名不是homes而是用户自己的标识符，对于单纯的文件共享的环境来说，这部分可以注视掉。</p><p>[printers] 该部分内容设置打印机共享。</p><p>samba实践</p><p>共享一个目录，任何人都可以访问，即不用输入密码即可访问，要求只读</p><p>修改全局的设置 vim /etc/samba/smb.conf</p><p>  [global]<br>  WORKGROUP = WORKGROUP<br>  security = share<br>然后在配置文件的末尾添加一行</p><p>   [share]#文件夹的名字<br>           comment = share all<br>           path = /var/www/html<br>           browseable = yes<br>           public = yes<br>           writable = no<br>启动samba共享服务</p><p>   /etc/init.d/smb start</p><p>   service smb start</p><p>   testparm    #测试配置文件<br>在windows主机c1上面打开浏览器或者资源管理器地址栏中输入</p><p>   file:///10.11.58.158/share    #可查看</p><p>   liunx 访问smbclient<br>共享一个目录，使用用户名和密码登录后才可以访问，要求可以读写</p><p>修改全局配置文件</p><p>[global]<br>        workgroup = WORKGROUP<br>        server string = Samba Server Version %v<br>        security = user<br>        passdb backend = tdbsam<br>        load printers = yes<br>        cups options = rawpa<br>添加一个新的共享设置</p><p>[myshare]<br>        comment = share for users<br>        path = /var/www/html<br>        browseable = yes<br>        writable = yes<br>        public = no<br>保存配置文件，修改共享目录权限!!!</p><p>mkdir /samba<br>chmod 777 /samba<br>然后添加用户</p><p>useradd user1    #创建测试用户<br>useradd user2    #创建测试用户</p><p>pdbedit -a user1    #添加用户为samba的用户<br>pdbedit -a user2    </p><p>pdbedit -L    #列出所有的samba用户</p><p>service smb restart    #重启samba服务<br>在windows主机上面打开浏览器或者资源管理器进行查看</p><p>使用linux访问samba服务器</p><p>在另一台的linux的客户端c2主机上面进行操作</p><p>yum install -y samba-client    #安装samba客户端</p><p>smbclient //IP/共享名 -U 用户名<br>smbclient //10.11.53.133/myshare -U user1   //-u 使用账号登录</p><p>#常用命令，使用help + 命令进行查看命令用法<br>cd, ls, rm, pwd, tar, mkdir, chown, get, put</p><p>#手动进行挂载<br>mount -t cifs //10.11.53.133/myshare /mnt/smb -o username=user1,password=123456</p><p>#在/etc/fstab上面进行挂载<br>//10.11.53.133/myshare /mnt/smb cifs username=user1,password=123456 0 0</p><p>file://10.11.53.133<br>linux挂载windows的共享目录</p><p>要在linux系统执行以下命令</p><p>yum install -y cifs-utils    #必须要安装这个组件，才可以完美支持<br>使用sbmclient来进行查看</p><p>smbclient //192.168.2.103/share -U ruidong<br>使用mount进行挂载，也可以设置为开启挂载！！在挂载硬盘</p><p>   mount -t cifs //192.168.2.103/share /mnt/smb -o username=ruidong,password=rd920128</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;简介&quot;&gt;&lt;a href=&quot;#简介&quot; class=&quot;headerlink&quot; title=&quot;简介&quot;&gt;&lt;/a&gt;简介&lt;/h2&gt;&lt;p&gt;samba主要运用与windows电脑与linux主机之间进行文件共享&lt;/p&gt;
&lt;p&gt;软硬件环境&lt;br&gt;
    
    </summary>
    
      <category term="Linux" scheme="https://dyl521.github.io/categories/Linux/"/>
    
    
      <category term="centos" scheme="https://dyl521.github.io/tags/centos/"/>
    
      <category term="samba" scheme="https://dyl521.github.io/tags/samba/"/>
    
      <category term="linux与window文件共享" scheme="https://dyl521.github.io/tags/linux%E4%B8%8Ewindow%E6%96%87%E4%BB%B6%E5%85%B1%E4%BA%AB/"/>
    
  </entry>
  
  <entry>
    <title>ScrollView常用属性汇总</title>
    <link href="https://dyl521.github.io/2015/03/08/Untitled/"/>
    <id>https://dyl521.github.io/2015/03/08/Untitled/</id>
    <published>2015-03-08T12:00:00.000Z</published>
    <updated>2018-07-08T12:21:16.175Z</updated>
    
    <content type="html"><![CDATA[<h2 id="ScrollView常用属性汇总"><a href="#ScrollView常用属性汇总" class="headerlink" title="ScrollView常用属性汇总"></a>ScrollView常用属性汇总</h2><p>android:scrollbars<br>设置滚动条显示。none（隐藏），horizontal（水平），vertical（垂直）<br><a id="more"></a><br>android:scrollbarSize<br>设置滚动条的宽度。</p><p>android:scrollbarStyle<br>设置滚动条的风格和位置。设置值：insideOverlay、insideInset、outsideOverlay、outsideInset<br> 其中inside和outside分别表示是否在view的padding区域内，overlay和inset表示覆盖在view上或是插在view后面，所以四种值分别表示：<br>insideOverlay：默认值，表示在padding区域内并且覆盖在view上<br>insideInset：表示在padding区域内并且插入在view后面<br>outsideOverlay：表示在padding区域外并且覆盖在view上，推荐这个<br>outsideInset：表示在padding区域外并且插入在view后面</p><p>android:scrollbarThumbHorizontal<br>设置水平滚动条的drawable（如颜色）<br> 00000000<br>android:scrollbarThumbVertical<br>设置垂直滚动条的drawable.</p><p>android:scrollbarTrackHorizontal<br>设置水平滚动条背景（轨迹）的色drawable（如颜色）</p><p>android:scrollbarTrackVertical<br>设置垂直滚动条背景（轨迹）的drawable注意直接设置颜色值<br>android:soundEffectsEnabled<br>设置点击或触摸时是否有声音效果</p><p>android:scrollbarDefaultDelayBeforeFade<br>设置N毫秒后开始淡化，以毫秒为单位。</p><p>android:scrollbarFadeDuration<br>设置滚动条淡出效果（从有到慢慢的变淡直至消失）时间，以毫秒为单位。Android2.2中滚动条滚动完之后会消失，再滚动又会出来，在1.5、1.6版本里面会一直显示着。</p><p>android:scrollbarAlwaysDrawVerticalTrack<br>设置是否始终显示垂直滚动条。这里用ScrollView、ListView测试均没有效果。</p><p>android:scrollbarAlwaysDrawHorizontalTrack<br>设置是否始终显示垂直滚动条。这里用ScrollView、ListView测试均没有效果。</p><p>android:fadeScrollbars<br>是否隐藏滚动条</p><p>ps:scrollview在java中的方法：<br>scroll.setVerticalScrollBarEnabled(false);<br>setHorizontalScrollBarEnabled(false);<br>boolean isVerticalScrollBarEnabled();<br>boolean isHorizontalScrollBarEnabled();</p><p>删除拉到尽头再拉的阴影效果<br>一、删除android ScrollView边界阴影方法方法<br>1） 在xml中添加：android:fadingEdge=”none”<br>2） 代码中添加：ScrollView.setHorizontalFadingEdgeEnabled(false);</p><p>二、删除ScrollView拉到尽头（顶部、底部），然后继续拉出现的阴影效果<br>    适用于2.3及以上的 否则不用设置<br>    android:overScrollMode=”never”</p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;ScrollView常用属性汇总&quot;&gt;&lt;a href=&quot;#ScrollView常用属性汇总&quot; class=&quot;headerlink&quot; title=&quot;ScrollView常用属性汇总&quot;&gt;&lt;/a&gt;ScrollView常用属性汇总&lt;/h2&gt;&lt;p&gt;android:scrollbars&lt;br&gt;设置滚动条显示。none（隐藏），horizontal（水平），vertical（垂直）&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dyl521.github.io/categories/Android/"/>
    
    
      <category term="控件属性" scheme="https://dyl521.github.io/tags/%E6%8E%A7%E4%BB%B6%E5%B1%9E%E6%80%A7/"/>
    
  </entry>
  
  <entry>
    <title>RelativeLayout属性</title>
    <link href="https://dyl521.github.io/2015/03/01/RelativeLayout%E5%B1%9E%E6%80%A7/"/>
    <id>https://dyl521.github.io/2015/03/01/RelativeLayout属性/</id>
    <published>2015-03-01T12:05:00.000Z</published>
    <updated>2018-07-08T13:50:20.582Z</updated>
    
    <content type="html"><![CDATA[<p>RelativeLayout的各种属性整理<br>相对于兄弟元素<br><a id="more"></a><br>android:layout_below=”@id/aaa”：在指定View的下方<br>android:layout_above=”@id/xxx”：在指定View的上方<br>android:layout_toLeftOf=”@id/bbb”：在指定View的左边<br>android:layout_toRightOf=”@id/cccc”：在指定View的右边相对于兄弟元素<br>android:layout_below=”@id/aaa”：在指定View的下方<br>android:layout_above=”@id/xxx”：在指定View的上方<br>android:layout_toLeftOf=”@id/bbb”：在指定View的左边<br>android:layout_toRightOf=”@id/cccc”：在指定View的右边</p><p>相对于父元素<br>android:layout_alignParentLeft=”true”：在父元素内左边<br>android:layout_alignParentRight=”true”：在父元素内右边<br>android:layout_alignParentTop=”true”：在父元素内顶部<br>android:layout_alignParentBottom=”true”：在父元素内底部</p><p>对齐方式<br>android:layout_centerInParent=”true”：居中布局<br>android:layout_centerVertical=”true”：水平居中布局<br>android:layout_centerHorizontal=”true”：垂直居中布局<br>android:layout_alignTop=”@id/xxx”：与指定View的上边界一致<br>android:layout_alignBottom=”@id/xxx”：与指定View下边界一致<br>android:layout_alignLeft=”@id/xxx”：与指定View的左边界一致<br>android:layout_alignRight=”@id/xxx”：与指定View的右边界一致</p><p>间隔<br>android:layout_marginBottom=””; 离某元素底边缘的距离<br>android:layout_marginLeft=””; 离某元素左边缘的距离<br>android:layout_marginRight =””;离某元素右边缘的距离<br>android:layout_marginTop=””; 离某元素上边缘的距离<br>android:layout_paddingBottom=””; 离父元素底边缘的距离<br>android:layout_paddingLeft=””; 离父元素左边缘的距离<br>android:layout_paddingRight =””;离父元素右边缘的距离<br>android:layout_paddingTop=””; 离父元素上边缘的距离</p><p>margin 与padding 区别<br>padding是站在父view的角度，是自己的内容与其父控件的边之间的距离。margin则是站在自己的角度描述问题，自己与旁边的某个组件的距离，如果同一级只有一个view，那么它的效果基本上就和padding一样了</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;RelativeLayout的各种属性整理&lt;br&gt;相对于兄弟元素&lt;br&gt;
    
    </summary>
    
      <category term="Android" scheme="https://dyl521.github.io/categories/Android/"/>
    
    
      <category term="RelativeLayout" scheme="https://dyl521.github.io/tags/RelativeLayout/"/>
    
  </entry>
  
  <entry>
    <title>Hello World</title>
    <link href="https://dyl521.github.io/2014/05/07/Hello-World/"/>
    <id>https://dyl521.github.io/2014/05/07/Hello-World/</id>
    <published>2014-05-07T14:32:00.000Z</published>
    <updated>2018-07-08T11:58:12.940Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="noopener">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="noopener">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="noopener">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="noopener">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">"My New Post"</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="noopener">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="noopener">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="noopener">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="noopener">Deployment</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;
    
    </summary>
    
    
  </entry>
  
</feed>
